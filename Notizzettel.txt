// ====================================

Seminar "C++ Moderne Design Pattern"

Peter Loos

Guten Morgen

// ====================================
// ====================================

30+ Jahre : SW - Entwicklung // Training

Pascal, C/C++, Java, C#, Mobile Progr. (Android) // Python

Back-to-the-Roots: C/C++

======================================

Tooling

a) Visual Studio

b) Unterlagen:

   Github.com / pelocpp

   https://github.com/pelocpp/cpp_design_patterns

==============================================

== Erwartungen
== Was muss drin sein ...
== Überblick
== Background // andere Sprachen ...

== C / Entscheidungen / Palette von Pattern

   Emdedded / Sensorik

   Frontend / Qt  

==============================================

Vorbemerkung:

Wahrscheinlichkeit:  Hmm, mit Gewalt Pattern einsetzen ....

a) kennen lernen

b) Problem: sich erinnern // da war doch was ...

==============================================

Fragen:

C++: Classic C++

C++: (C++11) Modern C++

C++ ==> komplex: Was verwenden wir von C++ ????

    Das, was wir verstehen :)

==============================================

ToDo-Liste:

== Rest der Idiome

== Literatur

== Virtueller Basisklassendestruktor

== std::unique //   std::shared_ptr


==============================================

Was ist ein Entwurfsmuster?

Gebrauchsanweisung // bewährt.

==> Idiom: Sind einfacher // kleiner ...

==============================================

Wie vermittle ich ein Idiom:

i)   Bildchen // UML

ii)  Konzeptionelle Beispiel:

     Umsetzung des Patterns - minimalistisch.

iii) Real-World Beispiel:

==============================================



Grundlagen:

Historisch entstande:

 1994   // Java

 Modernisiert:  C++


 Historisch ==> C++

 C++ Grundlagen:  Interface // Abstract Class


 =========================================

 Interfaces:

 Wozu ????

 Abstrakte Klasse:  Unvollständige Klasse

 Wann virtual und wann nicht ??????????????

 a)

        virtual void paint()                 // (virtual) method with implementation
        { 
        }

    class Button
    {
    public:
        // Teilfunktionalität
        virtual void paint()                 // (virtual) method with implementation
        { 
           // hier sollte alles "gemalt" werden,
           // was für ALLE Buttons relevant ist: Border zB // Background
        }

        // Fensterüberschrift
        virtual std::string caption () = 0;
        
        Rectangle size () { return Rectangle(10, 20); }
    }

    class ColoredButton : Button
    {
         //   void painttt() override {
         //   }

        // Verfeinerung der Teilfunktionalität
        void paint() override               // (virtual) method with implementation
        { 
            // Häufig:
            Button::paint(); // die Methode desselben Names
                             // in der Vaterklasse aufrufen
        }

        // verdecken: das ist schlechter Stil !!!!!!!!!
        virtual Rectangle size () { return Rectangle(10, 20); }
    }

    class BlackWhiteButton : Button


Frage:

Beobachtung:

Es wird eine virtuelle Mehthode überschrieben,
und in dieser wird etwas ganz anderes gemacht :)

==>  Hmm, da ist die ist-ein Beziehung verletzt.

Smell // Code Smell

===========================================================

Vererbung:

Klasse:  class // Member Variablen // Methoden  

Wann setzen wir in unseren Programmen Vererbung ein ?????

Beispiel:

Klasse Rectangle 
Klasse ColoredRectangle

Ein farbiges Rechteck ist eine Art von Rechteck

Ein farbiges Rechteck ist ein Rechteck.

Beziehungen // Relationsships:

ist-ein // is-a Relationsship

------------------------------------------

Klasse Point 
Klasse Line

Ein Punkt und eine Linie sind beides Formen,
Ein Punkt ist keine Linie

Eine Linie wird aus Punkten gebildet.
Eine Linie hat einen Anfangs- und Endpunkt // hat zwei Punkte .

a) Ein Punkt ist eine Linie: Nein.
b) Eine Linie ist ein Punkt: Nein

/ class Line : public Point


2. Beziehung: has-a // hat-ein  Beziehung:

class Line
{
    Point m_begin;
    Point m_end;
    ...
}


Matrix // LinearEquation

class Matrix : public LinearEquation

class LinearEquation
{
    Matrix m_data;
}


Abstrakte Methoden bewirken ein einheitliches AUssehen
von einer ganzen Hierarchie von Klassen.

=========================================================

Hierarchie: Vererbung.  

Häufig // weniger häufig.

Antwort: Häufig.

Sinnvoll:  Haben diese Klassen / Objekte ein
           ähnliches / gemeinsames Aussehen ???

Vererbung: Stärke:

Code wird wiederverwendet:

    "paint" in der Vaterklasse: Wird von allen Kindklassen verwendet.

Vererbung nicht "sklavisch" einsetzen:

Die Hat-Ein Beziehung kann manchmal einfacher sein.



Keyword 'override' // Von C# übernommen

// =============================================================

Idiome:

 „Separation of Concerns”  ===> 

 Lose Kopplung // Enge Kopplung

=======================================================

Adapter:

Ermöglicht die Interaktion von Objekten mit inkompatiblen Schnittstellen.

Datenformat:

XML
JSON

==> Handgestrickte Lösung.

Hübsche Lösung.

==========================================================

Thema Pointer:

Klassisch: new / delete

Modern:    Smart Pointer:  std::unique //   std::shared_ptr

class Adapter 
{
    Adaptee m_adaptee;   // member  // hat-ein

    // möglicherweise besser:
    
    Adaptee* m_adapteePtr;   // member  // hat-ein
        // new ===> Heap




}

void test()
{
    Adapter adapter;    // Stack // lokal
}


Wann Stack
Wann Heap

Was liegt alles am Stack ???

ALles, was in Methoden // Funktionen LOKAL // innerhalb dieser vereinbart
wird.

void test()
{
    int n;
    ...
}

int test()
{
    int n;
    ...
    return n;
}

Wofür ist der Stack da ????
   == lokale Variablen 
   == Zwischenergebnisse
   == NICHT: für grössere Objekte  // Qt Widgets

grössere Objekte:

A) globale Variablen

B) Ich hätte gerne ein Objekt, wenn ich es brauche 
   .... und gebe es wieder frei, wenn ich es NICHT mehr brauche:


   new / delete:   dynamisches Objekt


std::vector<QtWidget*> containerAllerWidgets;

int test()
{
    QtWidget* w;

    w = new QtWidget(...);
    ...

    containerAllerWidgets.push_back (w);
    // 
    return 0;
}

// ======================================

Wer ist clientCode ???

Nahtstelle:  Client <==> Pattern

// =====================================

Frage: 

Wieweit muss ich mich an die Vorgaben eines Patterns halten ???

Am prinzipiellen Konzept sollte nichts geändert werden.

Details:
--------

class Adapter : public ITarget
{
private:
    Adaptee* m_adaptee2;  // new / delete

    oder

class Adapter : public ITarget
{
private:
    Adaptee m_adaptee;


Frage:  JSON

a) Eine Bibliothek wird benötigt.

b) Mit oder ohne Adapter ???

i) Ohne Adapter: Geht - aber ich habe eine "enge Kopplung" zu dieser Bibliothek:

   a) Name der Klasse
   b) Methode transform // Parameter

ii) Mit Adapter:

Eine "enge Kopplung" zu dieser Bibliothek:

   a) Name der Klasse
   b) Methode transform // Parameter

   ABER: All dies ist auf den Adapter LOKAL beschränkt.

Vorteil: Wechsel zu einem anderen JSON-Transformer: 

Einen zweiten Adapter schreiben.

Dieser sollte DASSELBE Interface wie der erste Adapter bedienen.

Setze ist hier ein Pattern ein:

a) das ist KEINE zentrale Stelle von meinem Projekt:

   Wenig Zeit: dann mache es schnell ....

b) Es riecht nach Änderungen / Erweiterungen: zentrale Stelle.

   Dann könnte der Einsatz eines Patters das Leben einfacher machen.

===================================================================

Proxy:

Bereitstellung eines Platzhalters (Stellvertreters) für ein anderes Objekt.

Sinnhaftigkeit:


Echten Objekten // Zielobjekt

Stellvertreter davorschalte:

Kontrollmöglichkeiten:

a) Logging ...

b) Zugriffsrechte ...

c) Sogar möglich: Zielmethode wird NICHT aufgerufen ...


Entkopplung:  

Schnell: Okay, muss das Zielobjekt um Logging erweitern.

Single Responsibility

// =============================================================

Adapter  

Proxy

// Beide verstecken ein Objekt

// Beide abstrahieren die Methoden eines Zielobjekts über ein Interface

Wann setze ich Adapter ein?
Wann setze ich Proxy ein?

Adapter:  Umsetzen: Von A nach B  // das ist im Adapter versteckt

Proxy: Eine Möglichkeit: Erweiterung von Methden eines Zielobjekts 

    Zusatzfunktionalität durch ein separates Objekt ergänzen.

Zweite Möglichkeit:

Lazy versus Eager // Cachung

Faul versus Gierig

Zielobjekt: Ist resourcen intensiv  // Bilder

Viewer:

Grossbilddarstellung:  draw

Kleinen Bilder:  Thumbnails ...

Wie kann man nur einen Viewer für viele 1000... Bilder realisieren ????

Mit Proxies, die dann eine on-demand Funktionalität umsetzen.

eager:  gierig :   Synchrones // sofortiges Bereitstellen von Daten

lazy:   bequem :   ASynchrones //  Bereitstellen von Daten, wenn erforderlich.

==================================================================

Beobachtung:  Richtig.

Idee // Hintergrund // Motivation: Sind unterschiedlich.

Unterschied:

Adapter: Die gewünschte Funktionalität (readJSON)
         ist in einem Interface zu beschreiben.

Proxy:   Es ist das gesamte 'public' Interface eines Zielobjekts 
         mit einer Schnittstelle zu beschreiben.

Proxy:   Kann verhindern, dass in das Ziel-Objekt gerufen wird.

         Hmm, das sehe ich bei einem Adapter nicht.


Frage:

Wie kann ich verhindern, dass Clients DIREKT auf ein RealSubject zugreifen.

a) RealSubject:  Header-File 

b) Objekte verstecken // Klassen verstecken.

i)  Zielobjekt ist NICHT direkt instanziierbar.

ii) Fabrik: Händigen Objekte aus // verstecken aber die Erstellungslogik.

Beispiel:

std::vector

// ==========================================================

Template Method
---------------

Spielerisch:

Tetris - Spiel:

Eine Reihe von Figuren "kommen von oben nach unten":

7 Figuren:

Beobachtung:  Alle obliegen denselben Regeln.

Ihre Bewegungsmöglichkeiten (links, rechts, unten) sind dieselben.

Pro Figur sind Einzelentscheidungen notwendig - auf Grund des Aussehens der Figur.

==> move : move für alle Figuren : 

   Template Method Pattern.   // Schablonenmethode.

   Eine Schablonenmethode für alle Figuren.


Rezept:  Ein an sich immer wiederkehrender, homogener Ablauf ist 
         an unterschiedlichen Objekten zu vollziehen.

         Diese können mit Überschreiben von Methoden diesen Ablauf modifizieren // vervollständigen.

         Die Schablonenmethde ist unvollständig - in Bezug auf den Aufruf
         abstrakter Methoden.

         ===> Homogene Struktur.

========================================================

Strategy Pattern:
-----------------

std::vector<Employees> numbers;

   // Nachname 
   // Vorname
   // Geb.Datum
   // Einstellungsdatum
   // Personalnummer

std::vector<int> numbers;

std::sort ( 
    numbers.begin(),
    numbers.end(),
    ???   // Strategie  // wie  
);

========================================

Strategy:  Eine Methode durch einen Basisklassenzeiger einschleusen.

C++: Geht anders // möglicherweise auch einfacher 

std::function<>

Eine Option, eine Methode (samt Objekt) in einer Variablen abzulegen.

Funktor:  Aufrufbares Objekt:

class X
{
     operator() ........
}


std::function: Ein Baustein von vielen anderen Bausteinen von Modern C++

Strategie:   Austauschen von Funktionszeigern

=============================================================

Decorator:
----------

Hüllen-Pattern

Was ist das Plus des Decorator-Patterns ???

Hinzufügen neuen Verhaltens zu Objekten, 
indem diese Objekte in speziellen Hüllen-Objekten platziert werden.

Whyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy

a) Klassische Weg, um neues Verhalten zu Objekten hinzuzufügen:

   Die Klasse ändern // 

   Die Klasse spezialisieren:  

   Neue Kind-Klasse, Methode überschreiben und hier das neue Verhalten hinzuzufügen.

   Beobachtung:   Es gibt in C++ (Modern) das keyword 'final'

   Man kann NICHT spezialisieren

b) Einfacherer Weg ... und diesen zur Laufzeit.
   

// =================================================

Legacy-Code:         Besucher  // Visitor

Auch hier ist der Legacy-Code anzufassen - aber:  minimalistisch.

// =================================================

Prototype - Pattern
-------------------

Virtueller Konstruktor

Erstelle eine Kopie eines Objekts durch einen Zeiger auf seinen Basistyp.

Erstelle eine Kopie eines Objekts: ????????????????????????? Darum geht es hier nicht.

Problem / Beispiel:

Game-Programming:

Figure* board[8][8];

Figure:    Figure Basisklasse aller Schachfiguren.

Bauer    // Pawn
Turm     // Rook
Königin  // Queen
Läufer   // Bishop
..

Nächsten Zug: 

Kopie des Bretts erstellen:


Kopie von "Figure* board[8][8]";

Hier würden Kopien von Adressen:

Ich will auch die Figuren kopieren.

Hmmm, welche Figur steht an board[0][0] ???????????

   Pawn, Bishop, etc.

   board[0][0] ->

Problem:

Erstelle eine Kopie eines Objekts
durch einen Zeiger auf seinen Basistyp.

Wie geht das ???

"Virtueller Konstruktor"

Lösung:

Kovarianz   // nicht kovariant

Was bedeutet das?

Abgeleitete, virtuelle Methoden müssen kovariante Rückgabetypen haben. // ????


===============================================================

Wie passt clone zu SRP // Single Responsibility ???

A) In der Tat: clone hat mit der eigentlichen Responsibility eher keinen Zusammenhang.

B) Es geht nicht anders: Die clone-Methode muss in der Hiearchie angesiedelt sein.

  is - a Beziehung.

Einen zweiten Versuch:

// eine Menge von Daten verwaltet
// Responsibility
class DataContainer : ICloneable, IEnumerable

ICloneable Schnittstelle  ==> Nur wenn einen Klasse dieses Interface (Rolle, Responsibility)
                 implementiert, können Kopien von Objekten dieser Klasse erstellt werden.

                  ==> Nur wenn einen Klasse dieses Interface (Rolle, Responsibility)
                 implementiert, können die Daten des Objekts einzeln der Reihe nach
                 durchlaufen werden.

                 begin(), end()  : Iteratoren-Konzept


C++:  Lebenszyklus   //  Objektmodell

Konstruktor, Destruktor
operator=
Kopierkonstruktor

===========================================================

Fabriken

Factory

== Simple Factory

== Factory Method

== Abstract Factory

== Simple Factory:

Erstellung von Objekten,
ohne dem Client die Erstellungslogik zur Verfügung zu stellen.

== Konstruktoren:

   -- Wie heißt die Klasse ??? Wie ist der / sind die Konstruktoren definiert.

Hmnmm, da könnte man anders denken:

Fabrik:  "Buchung für einen von der Umsazusteuer befreiten Gegenstand"

Wie identifiziere ich eine solche Buchung ???

Simpel:

"Zeichenkette"

Aufzählungstyp: enum 

// lesbare Konstanten,  symbolische Konstante

enum Buchung
{
    BuchungMitUST,           // 0
    BuchungOhneUST,          // 1
    BuchungMitABschreibung,  // 2
};



Eine Fabrik besitzt meistens eine Klassenmethode:

Was bewirkt das Schlüsselwort 'friend' ???

Für alle "Freunde" gilt:

Die 'private'_Member sind public:  Scharfes Schwert.

Puristen (Theorie): Don't use friend:

Praxis:  Wenn die Klasse der Begierde alles, was von Interesse ist,
über geeignete getter / setter offen legt, dann brauche ich 'friend' nicht wirklich.

Color red =  Color::FromArgb (255, 0, 0);

Warum nicht so ?????????????????????????????

Color red (255, 0, 0);

Warum auch hier eine Fabrik-Methode ????

Zweite Win-Situation:   Implizit ein Singleton.

Wenn 100 mal Color red =  Color::FromArgb (255, 0, 0);

aufgerufen wird: Es gibt  nur EIN Objekt mit diesen Werten.


mutable  // veränderbar

Immutable  // unveränderbar

==========================================================


SW kann aus Schichten bestehen

== Low-Level Schichten // Änderung

== High-Level Schichten

Die beiden Schichten hängen zusammen

Es gibt so etwas wie eine Integrität: Änderungen an der SCHNITTSTELLE des  Low-Level Moduls
                                      sind tabu.

                                      Die Innereien sind davon nicht betroffen.



Integrität: Wie --- Mit einer Schnitstelle.

// ============================================================

Performanz:

-- Thread-Pool:  Aufgaben /  Funktionen: Parallel

   Verschiedene Aufgaben // Funktionen hantieren.

   Berechnung: Einmal die Daten holt  ... alles lokal berechnen

Bemerkung: Thread laufen parallel

           // gemeinsame Daten ... Synchronisiert ... Mutex  .. 
           // Zwangsserialisierung

-- Nachrichtenwarteschlange // Ereigniswarteschlange:

                  Aufgaben /  Funktionen:  Sequentiell.


-- Object-Pool:  Optimierung für Objekte derselben Größe (Point, ...)  // Fixed-Size Objekt

                 new / delete
                 
                 Vorhandene Pool: Freispeicherverwaltung.

Singleton.

Optimierung:

Double-Checked Locking / Doppelt überprüfte Sperrung:

    m_mutex.lock();   // zuerst lock // teuer // langsam
    
    if (m_instance == nullptr) {
        m_instance = new Singleton{};
    }
    
    m_mutex.unlock();


Trick:

    Singleton* Singleton::getInstanceEx(const std::string& value)
    {
        // 95%: KEIN nullptr  // Lesenden Zugriff
        if (m_instance == nullptr)  // Wo ist hier die Sperre ??
        {
            std::lock_guard<std::mutex> lock{ m_mutex }; // Sperre
            if (m_instance == nullptr)  // <=== NOTE: double-check of m_instance being nullptr
            {
                m_instance = new Singleton{ value };
            }
        }

        return m_instance;
    }

====================================================

Observer
--------

Klassisches Problem:

Ein Objekt, das Zustände hat, die sich ändern
und für die man sich interessiert:

Aktien-Objekt: ==> Kurswert ==> Änderungen.

Wetter-Daten: ==>  Für viele Regionen ==> Änderungen.

Client: Die sich für Änderungen interessieren.

Benachrichtigen lässt .... Callback ...

Ad hoc Lösung: Aufgehübscht:   Observer - Pattern

Nomenklatur:

Ein Objekt, das Zustände hat:

    Subject, Event Source, Observable

Interessierten für Änderungen am Subject:

    Observer, Event Client, Client

Anmerkung:
==========

Man könnte auch ohne das Interface IObserver

    class IObserver {
    public:
        virtual ~IObserver() {};

        virtual void update(const std::string& messageFromSubject) = 0;

        //virtual void update() = 0;
        //virtual void ping() = 0;

    };

auskommen:

Alternativ:
-----------

Subject:  Die Observer via std::function Objekte:

std::function < void (const std::string&) > einObserver;

std::list< std::function < void (const std::string&) >  > m_observers;

============

============================================================

Das "einfachste" Pattern:

===> Fremd-Bibliothek   // uhhh, Schnittstelle schwer verständlich / komplex

===> Legacy-Code:   // uhhhhh, brauche ich, will ihn aber nicht anfassen ....

==> "Da schreiben wir mal ne Schicht drum rum":   Facade 

// Performanz ...

Beispiel:

Thread-Pool:  Win32 Thread Pool API

Da ist ein Beispiel einer komplexen Bibliothek.



Facade:

Adapter:

Beides "versteckt" Klassen im Hintergrund.

==> Adapter: Die Klasse(n) brauche ich;
    Sie haben inkompatible Schnittstellen
    Es erfolgt auf irgendeine Weise eine Umsetzung von Daten
    (( vorher // nacher // beiden ))

==> Facade:
    Eine Dritt-Bibliothek // Ansammlung von Klassen // existiert.
    Sie ist komplex // umfangreich .
    Eine Vereinfachung wäre hilfreich.

    Weitere Anwendung: Dritt-Bibliothek  ist eine C-Bibliothek.
    Gewünscht wäre eine C++-Bibliotek // Objekt-Orientierung.

    Beispiel:  CreateWindow.

    Was ist eine bekannte OO Facade der Win32 Systembibliothek ??

    .NET Klassenbibliothek // Kein C++  // C#


    =======================================
